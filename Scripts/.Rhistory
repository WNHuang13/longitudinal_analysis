i ~ 1
s ~ 1
i ~~ s
")
fit_lgm <- growth(model_lgm, data = df_model, missing = 'fiml')
df_model <- df_wide %>%
select(id, starts_with("ssw_"))
glimpse(df_wide)
# check missing data
missing_rate <- df_model %>%
summarise(pct_missing = mean(is.na(across(all_of(ssw_vars)))) * 100)
# check missing data
missing_rate <- df_model %>%
summarise(pct_missing = mean(is.na(across(starts_with("ssw_")))) * 100)
print(missing_rate)
# Latent Growth Model
df_model <- df_model %>%
mutate(across(starts_with("ssw_"), ~ . / 1000))
years <- c(1992, 1994, 1996, 1998, 2000, 2002, 2004, 2006,
2008, 2010, 2012, 2014, 2016, 2018, 2020)
years_scaled <- scale(years, center = 2006, scale = FALSE)
model_lgm <- paste0("
i =~ ", paste0("1*", ssw_vars, collapse = " + "), "
s =~ ", paste0(round(as.numeric(years_scaled), 1), "*", ssw_vars, collapse = " + "), "
i ~ 1
s ~ 1
i ~~ s
")
fit_lgm <- growth(model_lgm, data = df_model, missing = 'fiml')
ssw_vars <- paste0("ssw_", seq(1992, 2020, 2))
missing_rate <- df_model %>%
summarise(pct_missing = mean(is.na(across(all_of(ssw_vars)))) * 100)
print(missing_rate)
df_model <- df_model %>%
mutate(across(starts_with("ssw_"), ~ . / 1000))
model_lgm <- paste0("
i =~ ", paste0("1*", ssw_vars, collapse = " + "), "
s =~ ", paste0(round(as.numeric(years_scaled), 1), "*", ssw_vars, collapse = " + "), "
i ~ 1
s ~ 1
i ~~ s
")
fit_lgm <- growth(model_lgm, data = df_model, missing = 'fiml')
summary(fit_lgm, fit.measures = TRUE, standardized = TRUE)
id_vars <- c("HHID", "PN")
ssw_vars <- grep("^R[0-9]+SSWRXA$", names(SSWEALTH), value = TRUE)
claim_vars <- grep("^R[0-9]+CLAIMED$", names(SSWEALTH), value = TRUE)
ssw_spouse_vars <- grep("^S[0-9]+SSWRXA$", names(SSWEALTH), value = TRUE)
ssw_house_vars  <- grep("^H[0-9]+SSWRXA$", names(SSWEALTH), value = TRUE)
df <- SSWEALTH %>%
select(all_of(id_vars), all_of(ssw_vars), all_of(claim_vars))
# Reshape from wide to long format
df_long <- df %>%
pivot_longer(cols = starts_with("R"),names_to = "wave", values_to = "ssw_r") %>%
mutate(
wave = as.numeric(str_extract(wave, "[0-9]+")),
id = paste(HHID, PN, sep = "_")
) %>%
arrange(id, wave)
# Add year variable
df_long <- df_long %>%
mutate(year = 1990 + 2 * wave)
# Quick overall missing rate
df_long %>%
summarise(
total_rows = n(),
missing_ssw = sum(is.na(ssw_r)),
pct_missing = round(mean(is.na(ssw_r)) * 100, 2)
)
# Missing rate per wave
df_long %>%
group_by(wave) %>%
summarise(
n = n(),
missing_n = sum(is.na(ssw_r)),
pct_missing = round(mean(is.na(ssw_r)) * 100, 2)
)
df_long %>%
group_by(wave) %>%
summarise(pct_available = (1 - mean(is.na(ssw_r))) * 100) %>%
ggplot(aes(x = wave, y = pct_available)) +
geom_col(fill = "steelblue") +
theme_minimal() +
labs(title="Percentage of Available SSW Data by Wave",y="Available", x="Wave")
Ensure unique
# Select relevant variables
df_model <- df_wide %>%
select(id, starts_with("ssw_"))
# check missing data
missing_rate <- df_model %>%
summarise(pct_missing = mean(is.na(across(all_of(ssw_vars)))) * 100)
glimpse(df_wide)
ssw_vars <- paste0("ssw_", seq(1992, 2020, 2))
# Select relevant variables
df_model <- df_wide %>%
select(id, starts_with("ssw_"))
# check missing data
missing_rate <- df_model %>%
summarise(pct_missing = mean(is.na(across(all_of(ssw_vars)))) * 100)
# Latent Growth Model
df_model <- df_model %>%
mutate(across(starts_with("ssw_"), ~ . / 1000))
years <- c(1992, 1994, 1996, 1998, 2000, 2002, 2004, 2006,
2008, 2010, 2012, 2014, 2016, 2018, 2020)
years_scaled <- scale(years, center = 2006, scale = FALSE)
model_lgm <- paste0("
i =~ ", paste0("1*", ssw_vars, collapse = " + "), "
s =~ ", paste0(round(as.numeric(years_scaled), 1), "*", ssw_vars, collapse = " + "), "
i ~ 1
s ~ 1
i ~~ s
")
missing_rate <- df_model %>%
summarise(pct_missing = mean(is.na(across(all_of(ssw_vars)))) * 100)
print(missing_rate)
model_lgm <- paste0("
i =~ ", paste0("1*", ssw_vars, collapse = " + "), "
s =~ ", paste0(round(as.numeric(years_scaled), 1), "*", ssw_vars, collapse = " + "), "
i ~ 1
s ~ 1
i ~~ s
")
fit_lgm <- growth(model_lgm, data = df_model, missing = 'fiml')
summary(fit_lgm, fit.measures = TRUE, standardized = TRUE)
# The model did not fit the data well, so a quadratic term was added
years_scaled2 <- (years_scaled)^2
model_lgm2 <- paste0("
i =~ ", paste0("1*", ssw_vars, collapse = " + "), "
s =~ ", paste0(round(as.numeric(years_scaled), 1), "*", ssw_vars, collapse = " + "), "
q =~ ", paste0(round(as.numeric(years_scaled2), 1), "*", ssw_vars, collapse = " + "), "
i ~ 1
s ~ 1
q ~ 1
i ~~ s + q
s ~~ q
")
fit_lgm2 <- growth(model_lgm2, data = df_model, missing = 'fiml')
summary(fit_lgm2, fit.measures = TRUE, standardized = TRUE)
# Latent Basis Model
ssw_vars <- paste0("ssw_", seq(1992, 2020, 2))
model_basis <- paste0("
i =~ 1*", paste(ssw_vars, collapse = " + 1*"), "
# Latent Basis Model
ssw_vars <- paste0("ssw_", seq(1992, 2020, 2))
ssw_vars <- paste0("ssw_", seq(1992, 2020, 2))
model_basis <- paste0("
i =~ 1*", paste(ssw_vars, collapse = " + 1*"), "
s =~ 0*", ssw_vars[1], " + NA*", ssw_vars[2], " + ",
paste0(ssw_vars[3:(length(ssw_vars)-1)], collapse = " + "), " + 1*", ssw_vars[length(ssw_vars)], "
i ~ 1
s ~ 1
i ~~ s")
fit_basis <- growth(model_basis, data = df_model, missing = "fiml")
summary(fit_basis, fit.measures = TRUE, standardized = TRUE)
library(tidyverse)
library(lme4)
library(lmerTest)
library(ggplot2)
df_long <- df_long %>%
rename(ssw = ssw_r) %>%
mutate(
year = as.numeric(year),
ssw = ssw / 1000,
year_c = year - 2006)
# HLM
# Random intercept
hlm_int <- lmer(ssw ~ year_c + (1 | id), data = df_long, REML = FALSE)
#Random intercept +slope
hlm_slope <- lmer(ssw ~ year_c + (year_c | id), data = df_long, REML = FALSE)
# Compare model
anova(hlm_int, hlm_slope)
summary(hlm_slope)
VarCorr(hlm_slope)
pred_df <- df_long %>%
group_by(year) %>%
summarize(predicted = predict(
hlm_slope,
newdata = data.frame(year_c = year - 2006, id = NA),
re.form = NA
))
# Compare model
anova(hlm_int, hlm_slope)
summary(hlm_slope)
VarCorr(hlm_slope)
pred_df <- df_long %>%
group_by(year) %>%
summarize(predicted = predict(
hlm_slope,
newdata = data.frame(year_c = year - 2006, id = NA),
re.form = NA
))
obs_df <- df_long %>%
group_by(year) %>%
summarize(mean_ssw = mean(ssw, na.rm = TRUE))
ggplot() +
geom_line(data = obs_df, aes(x = year, y = mean_ssw),
color = "gray50", size = 1, linetype = "dashed") +
geom_line(data = pred_df, aes(x = year, y = predicted),
color = "darkorange", size = 1.2) +
theme_minimal(base_size = 13) +
labs(
title = "HLM: Average Growth Trajectory (1992–2020)",
subtitle = "Orange line = Model prediction; Gray dashed line = Observed mean",
x = "Year",
y = "Social Security Wealth (thousand units)"
)
ggplot_2() +
geom_line(data = obs_df, aes(x = year, y = mean_ssw),
color = "gray50", size = 1, linetype = "dashed") +
geom_line(data = pred_df, aes(x = year, y = predicted),
color = "darkorange", size = 1.2) +
theme_minimal(base_size = 13) +
labs(
title = "HLM: Average Growth Trajectory (1992–2020)",
subtitle = "Orange line = Model prediction; Gray dashed line = Observed mean",
x = "Year",
y = "Social Security Wealth (thousand units)"
)
library(tidyverse)
library(lavaan)
library(ggplot2)
df_long <- df_long %>%
rename(X = ssw_r) %>%
mutate(
X = X / 1000,
year = as.numeric(year)
)
glimpse(df_long)
df_long <- df_long %>%
rename(X = ssw) %>%
mutate(
X = X / 1000,
year = as.numeric(year)
)
if(!"income" %in% names(df_long)) {
set.seed(123)
df_long <- df_long %>%
group_by(id) %>%
mutate(income = X + rnorm(n(), 0, 10))
}
df_wide <- df_long %>%
select(id, year, X, income) %>%
pivot_wider(
names_from = year,
values_from = c(X, income),
names_sep = "_"
)
glimpse(df_wide)
model_clpm <- '
# autoregressive paths
X_1994 ~ a1*X_1992
X_1996 ~ a2*X_1994
Y_1994 ~ b1*Y_1992
Y_1996 ~ b2*Y_1994
# cross-lagged paths
X_1994 ~ c1*Y_1992
X_1996 ~ c2*Y_1994
Y_1994 ~ d1*X_1992
Y_1996 ~ d2*X_1994
# correlations
X_1992 ~~ Y_1992
X_1994 ~~ Y_1994
X_1996 ~~ Y_1996
'
df_wide <- df_wide %>%
mutate(across(starts_with("X_"), ~ map_dbl(., ~ mean(unlist(.), na.rm = TRUE)))) %>%
mutate(across(starts_with("income_"), ~ map_dbl(., ~ mean(unlist(.), na.rm = TRUE))))
df_wide <- df_wide %>%
select(id,
X_1992, X_1994, X_1996,
income_1992, income_1994, income_1996)
model_clpm <- '
# autoregressive (stability) paths
X_1994 ~ a1*X_1992
X_1996 ~ a2*X_1994
income_1994 ~ b1*income_1992
income_1996 ~ b2*income_1994
# cross-lagged effects
X_1994 ~ c1*income_1992
X_1996 ~ c2*income_1994
income_1994 ~ d1*X_1992
income_1996 ~ d2*X_1994
# within-wave correlations
X_1992 ~~ income_1992
X_1994 ~~ income_1994
X_1996 ~~ income_1996
'
# --- 5. Fit model with FIML ----------------------------------------
fit_clpm <- sem(model_clpm, data = df_wide, missing = "fiml")
# --- 6. Inspect results ---------------------------------------------
summary(fit_clpm, fit.measures = TRUE, standardized = TRUE)
params <- parameterEstimates(fit_clpm, standardized = TRUE) %>%
filter(op == "~")
ggplot(params, aes(x = rhs, y = std.all, fill = lhs)) +
geom_col(position = "dodge") +
coord_flip() +
theme_minimal(base_size = 13) +
labs(
title = "Cross-Lagged Panel Model (SSW ↔ Income)",
subtitle = "Standardized regression coefficients",
x = "Predictor (previous wave)",
y = "Standardized β"
)
# --- 9. Optional: model fit indices ---------------------------------
fitMeasures(fit_clpm, c("cfi", "tli", "rmsea", "srmr"))
library(semPlot)
semPaths(
fit_clpm,
whatLabels = "std",     # 显示标准化系数
layout = "circle2",     # 节点布局方式（可选 spring / tree / circle）
edge.label.cex = 0.8,   # 文字大小
nCharNodes = 8,         # 节点名称长度
residuals = FALSE,      # 是否显示误差项
asize = 1.5,            # 箭头粗细
fade = FALSE,           # 不要淡化
title = FALSE,
edge.color = "black"
)
params <- parameterEstimates(fit_clpm, standardized = TRUE) %>%
filter(op == "~") %>%
mutate(from = rhs, to = lhs)
ggplot(params, aes(x = from, y = to, fill = std.all)) +
geom_tile(color = "white") +
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
theme_minimal(base_size = 12) +
labs(
title = "Cross-Lagged Effects (Standardized)",
x = "Predictor (previous wave)",
y = "Outcome (next wave)",
fill = "β"
)
params <- parameterEstimates(fit_clpm, standardized = TRUE) %>%
filter(op == "~") %>%
mutate(type = case_when(
grepl("X_", lhs) & grepl("X_", rhs) ~ "Autoregressive (SSW)",
grepl("income_", lhs) & grepl("income_", rhs) ~ "Autoregressive (Income)",
grepl("X_", lhs) & grepl("income_", rhs) ~ "Income→SSW",
grepl("income_", lhs) & grepl("X_", rhs) ~ "SSW→Income"
))
ggplot(params, aes(x=type, y=std.all, fill=type)) +
geom_bar(stat="identity", position="dodge") +
theme_minimal(base_size = 13) +
labs(title="Path Coefficient Comparison", y="Standardized β", x="Path Type") +
coord_flip()
library(tidyverse)
library(survival)
library(survminer)
df_surv <- df_long %>%
group_by(id) %>%
summarise(
time = max(year, na.rm = TRUE) - min(year, na.rm = TRUE),
ssw_mean = mean(ssw, na.rm = TRUE),
income_mean = mean(income, na.rm = TRUE),
event = max(event, na.rm = TRUE)
) %>%
ungroup()
name(SSWEALTH)
NAMES(SSWEALTH)
names(SSWEALTH)
library(tidyverse)
library(survival)
library(survminer)
df_long_raw <- SSWEALTH %>%
select(HHID, PN, matches("^R\\d+(SSWRXA|CLAIMED)$")) %>%
pivot_longer(
cols = -c(HHID, PN),
names_to   = c("wave","var"),
names_pattern = "^R(\\d+)(SSWRXA|CLAIMED)$",
values_to  = "value"
) %>%
mutate(
wave = as.integer(wave),
year = 1990 + 2*wave,                 # R1=1992, R2=1994, ..., R15=2020
id   = paste0(HHID, "_", PN)
) %>%
select(id, year, wave, var, value) %>%
pivot_wider(names_from = var, values_from = value)
df_long <- df_long_raw %>%
mutate(
SSWRXA   = suppressWarnings(as.numeric(SSWRXA)),
CLAIMED  = as.integer(CLAIMED),
ssw      = SSWRXA / 1000
) %>%
arrange(id, year)
df_surv <- df_long %>%
group_by(id) %>%
summarise(
start_year = suppressWarnings(min(year[!is.na(ssw) | !is.na(CLAIMED)], na.rm = TRUE)),
claim_year = if (any(CLAIMED == 1, na.rm = TRUE)) min(year[CLAIMED == 1], na.rm = TRUE) else NA_real_,
end_year   = ifelse(!is.na(claim_year), claim_year, suppressWarnings(max(year[!is.na(ssw) | !is.na(CLAIMED)], na.rm = TRUE))),
# Baseline covariate: ssw at or closest after start_year
ssw_base   = {
yy <- year[order(year)]
vv <- ssw[order(year)]
idx <- which.min(abs(yy - start_year))
if (length(idx) == 1) vv[idx] else NA_real_
},
# Alternative covariate: average ssw across follow-up
ssw_mean   = mean(ssw, na.rm = TRUE),
.groups = "drop_last"
) %>%
ungroup() %>%
mutate(
time  = pmax(end_year - start_year, 0),
event = ifelse(!is.na(claim_year), 1L, 0L)
) %>%
# Keep sensible records only
filter(is.finite(time), time >= 0)
# -------------------- 3. Kaplan–Meier estimation --------------------
surv_obj <- Surv(time = df_surv$time, event = df_surv$event)
fit_km <- survfit(surv_obj ~ 1)
print(summary(fit_km))
p_km <- ggsurvplot(
fit_km,
conf.int = TRUE,
xlab = "Years since first observation",
ylab = "Survival probability (no claiming yet)",
ggtheme = theme_minimal(base_size = 13),
title = "Time to First Social Security Claiming (Respondents)"
)
install.packages("survminer")
install.packages("survminer")
library(survival)
p_km <- ggsurvplot(
fit_km,
conf.int = TRUE,
xlab = "Years since first observation",
ylab = "Survival probability (no claiming yet)",
ggtheme = theme_minimal(base_size = 13),
title = "Time to First Social Security Claiming (Respondents)"
)
install.packages("survminer")
install.packages("survminer")
install.packages("survminer")
p_km <- ggsurvplot(
fit_km,
conf.int = TRUE,
xlab = "Years since first observation",
ylab = "Survival probability (no claiming yet)",
ggtheme = theme_minimal(base_size = 13),
title = "Time to First Social Security Claiming (Respondents)"
)
library(survival)
# Plot KM curve
# 使用 survival 包直接计算生存函数
fit_km <- survfit(Surv(time, event) ~ 1, data = df_surv)
km_df <- data.frame(
time = fit_km$time,
surv = fit_km$surv,
lower = fit_km$lower,
upper = fit_km$upper
)
ggplot(km_df, aes(x = time, y = surv)) +
geom_line(color = "steelblue", size = 1.2) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "lightblue", alpha = 0.3) +
theme_minimal(base_size = 13) +
labs(
title = "Time to First Social Security Claiming (Respondents)",
subtitle = "Kaplan–Meier survival curve",
x = "Years since first observation",
y = "Survival probability (no claiming yet)"
)
library(ggplot2)
ggplot(km_df, aes(x = time, y = surv)) +
geom_line(color = "steelblue", size = 1.2) +
geom_ribbon(aes(ymin = lower, ymax = upper), fill = "lightblue", alpha = 0.3) +
theme_minimal(base_size = 13) +
labs(
title = "Time to First Social Security Claiming (Respondents)",
subtitle = "Kaplan–Meier survival curve",
x = "Years since first observation",
y = "Survival probability (no claiming yet)"
)
# -------------------- 4. Cox proportional hazards -------------------
# Use baseline SSW (or switch to ssw_mean)
fit_cox <- coxph(Surv(time, event) ~ ssw_base, data = df_surv)
print(summary(fit_cox))
# Hazard ratios plot
cox_coef <- tidy(fit_cox, exponentiate = TRUE, conf.int = TRUE)
p_hr <- ggplot(cox_coef, aes(x = term, y = estimate, ymin = conf.low, ymax = conf.high)) +
geom_pointrange() +
geom_hline(yintercept = 1, linetype = "dashed") +
coord_flip() +
theme_minimal(base_size = 13) +
labs(
title = "Cox Model: Hazard Ratios for Claiming",
x = "Predictor",
y = "Hazard Ratio (exp(β))"
)
library(broom)
cox_coef <- tidy(fit_cox, exponentiate = TRUE, conf.int = TRUE)
p_hr <- ggplot(cox_coef, aes(x = term, y = estimate, ymin = conf.low, ymax = conf.high)) +
geom_pointrange() +
geom_hline(yintercept = 1, linetype = "dashed") +
coord_flip() +
theme_minimal(base_size = 13) +
labs(
title = "Cox Model: Hazard Ratios for Claiming",
x = "Predictor",
y = "Hazard Ratio (exp(β))"
)
p_hr <- ggplot(cox_coef, aes(x = term, y = estimate, ymin = conf.low, ymax = conf.high)) +
geom_pointrange() +
geom_hline(yintercept = 1, linetype = "dashed") +
coord_flip() +
theme_minimal(base_size = 13) +
labs(
title = "Cox Model: Hazard Ratios for Claiming",
x = "Predictor",
y = "Hazard Ratio (exp(β))"
)
p_hr
